# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/181OISQKBYSUD8AzgWPzBsszU7z0mI_ro
"""

import streamlit as st
import pandas as pd
import numpy as np
from collections import defaultdict, Counter
import io

st.title("ASSORTED BOX PACKING TEMPLATE")

uploaded_file = st.file_uploader("Upload the input file", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)
    sizes = ['S','M', 'L', 'XL', '2XL','3XL','4XL','5XL']
    final_output = []
    style_dict = df.set_index('COLOUR')['STYLE'].to_dict()

    for size in sizes:
        remaining_list = [(row['COLOUR'], row[size]) for _, row in df.iterrows()]
        colours = [colour for colour, _ in remaining_list]
        total_colours = len(colours)

        grouped = defaultdict(list)
        for colour, qty in remaining_list:
            grouped[colour].append(qty)

        colour_counts = pd.Series(colours).value_counts()
        duplicates = colour_counts[colour_counts > 1]

        if not duplicates.empty:
            combined = defaultdict(int)
            for colour, qty in remaining_list:
                combined[colour] += qty

            min_qty = min(combined.values())
            equalized = []
            adjusted = []

            for colour, total_qty in combined.items():
                times = len(grouped[colour])
                equal_qty = min_qty * times
                adjusted_qty = total_qty - equal_qty
                equalized.append((colour, equal_qty))
                adjusted.append((colour, adjusted_qty))

            total_remaining = sum(qty for _, qty in adjusted)
            box_qty = total_remaining // total_colours

            colour_counts = Counter(colours)
            repeated_colours = [colour for colour, count in colour_counts.items() if count > 1]
            repeated_total_qty = sum(qty for colour, qty in adjusted if colour in repeated_colours)

            unique_colours = {colour for colour, count in colour_counts.items() if count == 1}
            unique_sum = sum(qty for colour, qty in adjusted if colour in unique_colours)
            unique_count = len(unique_colours)

            box_qty1 = box_qty * max(colour_counts.values())

            if box_qty1 > repeated_total_qty:
                final_repeated_stock = {
                    colour: qty - (box_qty * colours.count(colour))
                    for colour, qty in adjusted
                }

                final_stock1 = []
                for colour, qty in equalized:
                    repeated_qty = final_repeated_stock.get(colour, 0)
                    final_stock1.append((colour, qty + repeated_qty))

                negative_sum = sum(qty for qty in final_repeated_stock.values() if qty < 0)
                adjusted_stock = [(colour, qty - abs(negative_sum)) for colour, qty in equalized]

                mix_box_pcs = [
                    (final_colour, final_qty - adjusted_qty)
                    for (final_colour, final_qty), (_, adjusted_qty) in zip(final_stock1, adjusted_stock)
                ]
                assorted_box_pcs = [(colour, qty + box_qty) for colour, qty in adjusted_stock]

                positives = [(c, q) for c, q in final_repeated_stock.items() if q > 0 and c not in repeated_colours]
                negatives = [(c, q) for c, q in final_repeated_stock.items() if q < 0]
                repeated = [(c, q) for c, q in final_repeated_stock.items() if c in repeated_colours]

                total_positive = sum(q for _, q in positives)
                total_negative = -sum(q for _, q in negatives)

                adjusted_qty = {}
                labels = {}

                for c, q in repeated:
                    adjusted_qty[c] = q
                    labels[c] = "single"

                for c, q in positives:
                    proportion = q / total_positive if total_positive else 0
                    deduction = round(proportion * total_negative)
                    remaining = max(q - deduction, 0)
                    adjusted_qty[c] = 1 if remaining > 0 else 0
                    labels[c] = "double"

                for c, _ in negatives:
                    adjusted_qty[c] = 0
                    labels[c] = "single"

                for (colour, assorted), (_, mix) in zip(assorted_box_pcs, mix_box_pcs):
                    final_output.append({
                        'STYLE': style_dict.get(colour, ''),
                        'SIZE': size,
                        'COLOUR': colour,
                        'Assorted_Box_Pcs': assorted,
                        'Mix_Box_Pcs': mix,
                        'Adjusted_Qty': adjusted_qty.get(colour, 0),
                        'Label': labels.get(colour, '')
                    })

            else:
                if unique_count > 0:
                    box_qty1 = unique_sum // unique_count

                final_repeated_stock1 = {
                    colour: qty - (box_qty1 * colours.count(colour))
                    for colour, qty in adjusted
                }

                final_stock1 = []
                for colour, qty in equalized:
                    repeated_qty = final_repeated_stock1.get(colour, 0)
                    final_stock1.append((colour, qty + repeated_qty))

                negative_sum = sum(qty for qty in final_repeated_stock1.values() if qty < 0)
                adjusted_stock = [(colour, qty - abs(negative_sum)) for colour, qty in equalized]

                mix_box_pcs = [
                    (final_colour, final_qty - adjusted_qty)
                    for (final_colour, final_qty), (_, adjusted_qty) in zip(final_stock1, adjusted_stock)
                ]

                assorted_box_pcs = [(colour, qty + box_qty1) for colour, qty in adjusted_stock]

                positives = [(c, q) for c, q in final_repeated_stock1.items() if q > 0 and c not in repeated_colours]
                negatives = [(c, q) for c, q in final_repeated_stock1.items() if q < 0]
                repeated = [(c, q) for c, q in final_repeated_stock1.items() if c in repeated_colours]

                total_positive = sum(q for _, q in positives)
                total_negative = -sum(q for _, q in negatives)

                adjusted_qty = {}
                labels = {}

                for c, q in repeated:
                    adjusted_qty[c] = q
                    labels[c] = "single"

                for c, q in positives:
                    proportion = q / total_positive if total_positive else 0
                    deduction = round(proportion * total_negative)
                    remaining = max(q - deduction, 0)
                    adjusted_qty[c] = 1 if remaining > 0 else 0
                    labels[c] = "double"

                for c, _ in negatives:
                    adjusted_qty[c] = 0
                    labels[c] = "single"

                for (colour, assorted), (_, mix) in zip(assorted_box_pcs, mix_box_pcs):
                    final_output.append({
                        'STYLE': style_dict.get(colour, ''),
                        'SIZE': size,
                        'COLOUR': colour,
                        'Assorted_Box_Pcs': assorted,
                        'Mix_Box_Pcs': mix,
                        'Adjusted_Qty': adjusted_qty.get(colour, 0),
                        'Label': labels.get(colour, '')
                    })

        else:
            combined = defaultdict(int)
            for colour, qty in remaining_list:
                combined[colour] += qty

            min_qty = min(combined.values())
            equalized = []
            adjusted = []

            for colour, total_qty in combined.items():
                times = len(grouped[colour])
                equal_qty = min_qty * times
                adjusted_qty = total_qty - equal_qty
                equalized.append((colour, equal_qty))
                adjusted.append((colour, adjusted_qty))

            total_remaining = sum(qty for _, qty in adjusted)
            box_qty = total_remaining // total_colours

            final_repeated_stock = {
                colour: qty - (box_qty * colours.count(colour))
                for colour, qty in adjusted
            }

            final_stock1 = []
            for colour, qty in equalized:
                repeated_qty = final_repeated_stock.get(colour, 0)
                final_stock1.append((colour, qty + repeated_qty))

            negative_sum = sum(qty for qty in final_repeated_stock.values() if qty < 0)
            adjusted_stock = [(colour, qty - abs(negative_sum)) for colour, qty in equalized]

            mix_box_pcs = [
                (final_colour, final_qty - adjusted_qty)
                for (final_colour, final_qty), (_, adjusted_qty) in zip(final_stock1, adjusted_stock)
            ]

            assorted_box_pcs = [(colour, qty + box_qty) for colour, qty in adjusted_stock]

            positives = [(c, q) for c, q in final_repeated_stock.items() if q > 0]
            negatives = [(c, q) for c, q in final_repeated_stock.items() if q < 0]

            debt = -sum(q for _, q in negatives)

            adjusted = []
            labels = {}
            remaining = debt

            for colour, qty in positives:
                if remaining <= 0:
                    adjusted.append((colour, qty))
                    labels[colour] = 'single'
                elif qty >= remaining:
                    adjusted.append((colour, qty - remaining))
                    labels[colour] = 'double'
                    remaining = 0
                else:
                    adjusted.append((colour, 0))
                    labels[colour] = 'double'
                    remaining -= qty

            final_stock2 = []
            final_labels = []
            for colour, qty in final_repeated_stock.items():
                if qty < 0:
                    final_stock2.append((colour, 0))
                    final_labels.append((colour, 'single'))
                else:
                    new_qty = next((x[1] for x in adjusted if x[0] == colour), 0)
                    final_stock2.append((colour, new_qty))
                    final_labels.append((colour, labels.get(colour, 'single')))

            stock_lookup = {c: q for c, q in final_stock2}
            label_lookup = {c: t for c, t in final_labels}

            for (colour, assorted), (_, mix) in zip(assorted_box_pcs, mix_box_pcs):
                final_output.append({
                    'STYLE': style_dict.get(colour, ''),
                    'SIZE': size,
                    'COLOUR': colour,
                    'Assorted_Box_Pcs': assorted,
                    'Mix_Box_Pcs': mix,
                    'final_stock2': stock_lookup.get(colour, 0),
                    'final_labels': label_lookup.get(colour, '')
                })

    output_df = pd.DataFrame(final_output)
    st.success("✅ Processing Complete")

    buffer = io.BytesIO()
    output_df.to_excel(buffer, index=False)
    buffer.seek(0)

    st.download_button(
        label="📥 Download Output Excel",
        data=buffer,
        file_name="Assorted_Box_Output.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )