# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aKn2t_7dZlj7XAVIbUObmZ16Rgg_K9CD
"""

import streamlit as st
import pandas as pd
import numpy as np
from collections import defaultdict, Counter
import math
import io

# --- Helper Functions ---

def compute_equalized_and_adjusted(grouped, size_data):
    combined = defaultdict(int)
    for colour, qty in size_data:
        combined[colour] += qty
    min_qty = min(combined.values())
    equalized = []
    adjusted = []
    for colour, total_qty in combined.items():
        times = len(grouped[colour])
        equal_qty = min_qty * times
        adjusted_qty = total_qty - equal_qty
        equalized.append((colour, equal_qty))
        adjusted.append((colour, adjusted_qty))
    return equalized, adjusted

def compute_final_repeated_stock(adjusted, box_qty, colours):
    return {
        colour: qty - (box_qty * colours.count(colour))
        for colour, qty in adjusted
    }

def adjust_negative_stock(equalized, final_repeated_stock, colours):
    negative_sum = sum(qty for qty in final_repeated_stock.values() if qty < 0)
    return [(colour, qty - abs(negative_sum) * colours.count(colour)) for colour, qty in equalized]

def compute_mix_box_pcs1(final_stock1, adjusted_stock):
    return [
        (final_colour, final_qty - adjusted_qty)
        for (final_colour, final_qty), (_, adjusted_qty) in zip(final_stock1, adjusted_stock)
    ]

def label_and_adjust(final_repeated_stock, repeated_colours):
    positives = [(c, q) for c, q in final_repeated_stock.items() if q > 0 and c not in repeated_colours]
    negatives = [(c, q) for c, q in final_repeated_stock.items() if q < 0]
    repeated = [(c, q) for c, q in final_repeated_stock.items() if c in repeated_colours]
    total_positive = sum(q for _, q in positives)
    total_negative = -sum(q for _, q in negatives)
    adjusted_qty = {}
    labels = {}
    for c, q in repeated:
        adjusted_qty[c] = q
        labels[c] = "single"
    for c, q in positives:
        proportion = q / total_positive if total_positive else 0
        deduction = round(proportion * total_negative)
        remaining = max(q - deduction, 0)
        adjusted_qty[c] = 1 if remaining > 0 else 0
        labels[c] = "double"
    for c, _ in negatives:
        adjusted_qty[c] = 0
        labels[c] = "single"
    return adjusted_qty, labels

# --- Streamlit App ---

st.title("ðŸ‘• Assorted Box Packing Tool")

uploaded_file = st.file_uploader("Upload ASSORTED Excel file", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)

    sizes = ['M', 'L', 'XL', '2XL']
    final_output = []
    style_dict = df.set_index('COLOUR')['STYLE'].to_dict()
    all_mix_boxes = []

    for size in sizes:
        remaining_list = [(row['COLOUR'], row[size]) for _, row in df.iterrows()]
        colours = [colour for colour, _ in remaining_list]
        total_colours = len(colours)
        grouped = defaultdict(list)
        for colour, qty in remaining_list:
            grouped[colour].append(qty)

        colour_counts = pd.Series(colours).value_counts()
        if (colour_counts >= 3).sum() >= 1:
            equalized, adjusted = compute_equalized_and_adjusted(grouped, remaining_list)
            total_remaining = sum(qty for _, qty in adjusted)
            box_qty = total_remaining // total_colours
            repeated_colours = [colour for colour, count in Counter(colours).items() if count > 1]
            repeated_total_qty = sum(qty for colour, qty in adjusted if colour in repeated_colours)
            unique_colours = {colour for colour, count in Counter(colours).items() if count == 1}
            unique_sum = sum(qty for colour, qty in adjusted if colour in unique_colours)
            unique_count = len(unique_colours)
            box_qty1 = box_qty * max(colour_counts.values())

            if box_qty1 > repeated_total_qty:
                final_repeated_stock = compute_final_repeated_stock(adjusted, box_qty, colours)
            else:
                box_qty1 = unique_sum // unique_count if unique_count > 0 else 0
                final_repeated_stock = compute_final_repeated_stock(adjusted, box_qty1, colours)

            final_stock1 = [(colour, qty + final_repeated_stock.get(colour, 0)) for colour, qty in equalized]
            adjusted_stock = adjust_negative_stock(equalized, final_repeated_stock, colours)
            mix_box_pcs1 = compute_mix_box_pcs1(final_stock1, adjusted_stock)
            current_state = final_repeated_stock.copy()
            mix_box_pcs = []

            for color, value in final_repeated_stock.items():
                if value < 0:
                    shortage = abs(value)
                    if colours.count(color) > 2:
                        boxes_to_open = shortage // 1
                        generated = {c: boxes_to_open for c, _ in equalized}
                        generated[color] -= shortage
                    else:
                        boxes_to_open = math.ceil(shortage / Counter(colours)[color])
                        generated = {c: boxes_to_open * Counter(colours)[c] for c in Counter(colours)}
                        generated[color] -= shortage

                    current_state[color] += shortage
                    remaining = shortage
                    for c in generated:
                        if c == color:
                            continue
                        if current_state[c] > 0 and remaining > 0:
                            take = min(remaining, current_state[c])
                            current_state[c] -= take
                            generated[c] += take
                            remaining -= take
                            if remaining == 0:
                                break
                    mix_box_pcs.append(generated.copy())

            assorted_box_pcs = [(colour, qty + box_qty * colours.count(colour)) for colour, qty in adjusted_stock]
            adjusted_qty, labels = label_and_adjust(final_repeated_stock, repeated_colours)
            mix_box_df = pd.DataFrame({f"MIX BOX {i+1}": list(box.values()) for i, box in enumerate(mix_box_pcs)})
            mix_box_df.insert(0, "COLOUR", list(mix_box_pcs[0].keys()))
            mix_box_df.insert(0, "SIZE", size)
            all_mix_boxes.append(mix_box_df)

            for (colour, assorted), (_, mix) in zip(assorted_box_pcs, mix_box_pcs1):
                final_output.append({
                    'STYLE': style_dict.get(colour, ''),
                    'SIZE': size,
                    'COLOUR': colour,
                    'Assorted_Box_Pcs': assorted,
                    'Mix_Box_Pcs': mix,
                    'Adjusted_Qty': adjusted_qty.get(colour, 0),
                    'Label': labels.get(colour, '')
                })

        else:
            equalized, adjusted = compute_equalized_and_adjusted(grouped, remaining_list)
            total_remaining = sum(qty for _, qty in adjusted)
            box_qty = total_remaining // total_colours
            final_repeated_stock = compute_final_repeated_stock(adjusted, box_qty, colours)
            final_stock1 = [(colour, qty + final_repeated_stock.get(colour, 0)) for colour, qty in equalized]
            adjusted_stock = adjust_negative_stock(equalized, final_repeated_stock, colours)
            mix_box_pcs1 = compute_mix_box_pcs1(final_stock1, adjusted_stock)
            mix_box_pcs = []

            current_state = final_repeated_stock.copy()
            for color, value in final_repeated_stock.items():
                if value < 0:
                    boxes_to_open = abs(value)
                    generated = {c: boxes_to_open for c, _ in equalized}
                    generated[color] -= boxes_to_open
                    current_state[color] += boxes_to_open
                    for c in current_state:
                        if current_state[c] > 0 and boxes_to_open > 0:
                            take = min(boxes_to_open, current_state[c])
                            current_state[c] -= take
                            generated[c] += take
                            boxes_to_open -= take
                            if boxes_to_open == 0:
                                break
                    mix_box_pcs.append(generated.copy())

            assorted_box_pcs = [(colour, qty + box_qty * colours.count(colour)) for colour, qty in adjusted_stock]
            positives = [(c, q) for c, q in final_repeated_stock.items() if q > 0]
            negatives = [(c, q) for c, q in final_repeated_stock.items() if q < 0]
            debt = -sum(q for _, q in negatives)
            adjusted = []
            labels = {}
            remaining = debt

            for colour, qty in positives:
                if remaining <= 0:
                    adjusted.append((colour, qty))
                    labels[colour] = 'single'
                elif qty >= remaining:
                    adjusted.append((colour, qty - remaining))
                    labels[colour] = 'double'
                    remaining = 0
                else:
                    adjusted.append((colour, 0))
                    labels[colour] = 'double'
                    remaining -= qty

            final_stock2 = []
            final_labels = []
            for colour, qty in final_repeated_stock.items():
                if qty < 0:
                    final_stock2.append((colour, 0))
                    final_labels.append((colour, 'single'))
                else:
                    new_qty = next((x[1] for x in adjusted if x[0] == colour), 0)
                    final_stock2.append((colour, new_qty))
                    final_labels.append((colour, labels.get(colour, 'single')))
            stock_lookup = dict(final_stock2)
            label_lookup = dict(final_labels)

            mix_box_df = pd.DataFrame({f"MIX BOX {i+1}": list(box.values()) for i, box in enumerate(mix_box_pcs)})
            mix_box_df.insert(0, "COLOUR", list(mix_box_pcs[0].keys()))
            mix_box_df.insert(0, "SIZE", size)
            all_mix_boxes.append(mix_box_df)

            for (colour, assorted), (_, mix) in zip(assorted_box_pcs, mix_box_pcs1):
                final_output.append({
                    'STYLE': style_dict.get(colour, ''),
                    'SIZE': size,
                    'COLOUR': colour,
                    'Assorted_Box_Pcs': assorted,
                    'Mix_Box_Pcs': mix,
                    'Adjusted_Qty': stock_lookup.get(colour, 0),
                    'Label': label_lookup.get(colour, '')
                })

    # Final output generation
    output_df = pd.DataFrame(final_output)
    output_df["Total_Qty"] = output_df["Assorted_Box_Pcs"] + output_df["Mix_Box_Pcs"] + output_df["Adjusted_Qty"]
    grouped = output_df.groupby(["STYLE", "SIZE"])[["Assorted_Box_Pcs", "Mix_Box_Pcs", "Adjusted_Qty", "Total_Qty"]].sum()

    percentage_df = pd.DataFrame()
    percentage_df["ASSORTED BOX%"] = (grouped["Assorted_Box_Pcs"] / grouped["Total_Qty"]) * 100
    percentage_df["MIX BOX%"] = (grouped["Mix_Box_Pcs"] / grouped["Total_Qty"]) * 100
    percentage_df["LOOSE PCS%"] = (grouped["Adjusted_Qty"] / grouped["Total_Qty"]) * 100
    percentage_df = percentage_df.reset_index()
    size_order = ["M", "L", "XL", "2XL"]
    percentage_df["SIZE"] = pd.Categorical(percentage_df["SIZE"], categories=size_order, ordered=True)
    percentage_df = percentage_df.sort_values(by=["STYLE", "SIZE"]).round(2)
    final_mix_box_df = pd.concat(all_mix_boxes, ignore_index=True)

    st.success("âœ… Excel processing complete!")
    st.subheader("ðŸ“Š Overall Output")
    st.dataframe(output_df)

    st.subheader("ðŸ“¦ Mix Box Breakdown")
    st.dataframe(final_mix_box_df)

    st.subheader("ðŸ“ˆ Box Percentages")
    st.dataframe(percentage_df)

    # Download link
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        output_df.to_excel(writer, sheet_name='OVERALL', index=False)
        final_mix_box_df.to_excel(writer, sheet_name='MIX BOX BREAKUP', index=False)
        percentage_df.to_excel(writer, sheet_name='BOX PERCENT', index=False)
    output.seek(0)

    st.download_button(
        label="ðŸ“¥ Download Final Excel",
        data=output,
        file_name="ASSORTED_PACKING_TEMPLATE.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )